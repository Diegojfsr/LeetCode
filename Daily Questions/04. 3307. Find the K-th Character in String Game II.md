## ğŸ§© Encontre o K-Ã©simo Caractere no Jogo de String II

Alice e Bob estÃ£o jogando um jogo. Inicialmente, Alice tem uma string `word = "a"`.
VocÃª recebe um nÃºmero inteiro positivo `k` e um array de inteiros `operations`, onde `operations[i]` representa o tipo da i-Ã©sima operaÃ§Ã£o.
Bob pedirÃ¡ que Alice execute todas as operaÃ§Ãµes na sequÃªncia:

- Se `operations[i] == 0`: anexe uma cÃ³pia da string `word` a ela mesma. Exemplo: `"ab"` se torna `"abab"`.
- Se `operations[i] == 1`: gere uma nova string alterando cada caractere de `word` para o prÃ³ximo caractere no alfabeto inglÃªs, e anexe essa nova string Ã  original. Exemplo:
    - `"c"` se torna `"cd"`
    - `"zb"` se torna `"zbac"` (pois `'z'` vira `'a'` e `'b'` vira `'c'`)

**Importante:** O caractere `'z'` se transforma em `'a'` na operaÃ§Ã£o do tipo 1.

### ğŸ§ª Exemplos

#### Exemplo 1:

**Entrada:** `k = 5`, `operations = [0, 0, 0]` **SaÃ­da:** `"a"` **ExplicaÃ§Ã£o:**

- Inicialmente: `"a"`
- OperaÃ§Ã£o 1 (0): `"a"` â†’ `"aa"`
- OperaÃ§Ã£o 2 (0): `"aa"` â†’ `"aaaa"`
- OperaÃ§Ã£o 3 (0): `"aaaa"` â†’ `"aaaaaaaa"`
- O 5Âº caractere Ã© `"a"`

#### Exemplo 2:

**Entrada:** `k = 10`, `operations = [0, 1, 0, 1]` **SaÃ­da:** `"b"` **ExplicaÃ§Ã£o:**

- Inicialmente: `"a"`
- OperaÃ§Ã£o 1 (0): `"a"` â†’ `"aa"`
- OperaÃ§Ã£o 2 (1): `"aa"` â†’ `"aabb"` (pois `'a'` vira `'b'`)
- OperaÃ§Ã£o 3 (0): `"aabb"` â†’ `"aabbaabb"`
- OperaÃ§Ã£o 4 (1): `"aabbaabb"` â†’ `"aabbaabbbbccbbcc"`
- O 10Âº caractere Ã© `"b"`

### ğŸ“ RestriÃ§Ãµes

- 1â‰¤kâ‰¤10141 \leq k \leq 10^{14}
- 1â‰¤operations.lengthâ‰¤1001 \leq \text{operations.length} \leq 100
- Cada `operations[i]` Ã© 0 ou 1
- A entrada Ã© garantida de forma que a string final terÃ¡ pelo menos `k` caracteres


### Solution

```c++

#include <vector>

class Solution {
public:
Â  Â  char kthCharacter(long long k, std::vector<int>& operations) {
Â  Â  Â  Â  long long powerOfTwo = 1; 
Â  Â  Â  Â  int index = 0;

Â  Â  Â  Â  while (powerOfTwo < k) {
Â  Â  Â  Â  Â  Â  powerOfTwo *= 2;
Â  Â  Â  Â  Â  Â  ++index;
Â  Â  Â  Â  }
Â  Â  Â  Â  int cumulativeShift = 0; 
Â  Â  Â  Â  while (powerOfTwo > 1) {
Â  Â  Â  Â  Â  Â  if (k > powerOfTwo / 2) {
Â  Â  Â  Â  Â  Â  Â  Â  k -= powerOfTwo / 2; 
Â  Â  Â  Â  Â  Â  Â  Â  cumulativeShift += operations[index - 1]; 
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  powerOfTwo /= 2; 
Â  Â  Â  Â  Â  Â  --index; 
Â  Â  Â  Â  }
Â  Â  Â  Â  return 'a' + (cumulativeShift % 26);
Â  Â  }
};
```


