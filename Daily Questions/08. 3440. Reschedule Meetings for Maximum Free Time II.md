### ğŸ§© Reagendar ReuniÃµes para o MÃ¡ximo de Tempo Livre II

VocÃª recebe:
- Um nÃºmero inteiro `eventTime`, que representa a duraÃ§Ã£o de um evento.
- Duas listas de inteiros `startTime` e `endTime`, cada uma de tamanho `n`.
Essas listas representam os horÃ¡rios de inÃ­cio e fim de `n` reuniÃµes sem sobreposiÃ§Ã£o, que acontecem entre o tempo `t = 0` atÃ© `t = eventTime`. A reuniÃ£o de Ã­ndice `i` ocorre durante o intervalo `[startTime[i], endTime[i]]`.
VocÃª pode reagendar no mÃ¡ximo uma reuniÃ£o, movendo seu horÃ¡rio de inÃ­cio (mantendo a mesma duraÃ§Ã£o), desde que ela continue nÃ£o sobrepondo as outras.

ğŸ¯ O objetivo Ã© maximizar o perÃ­odo contÃ­nuo mais longo de tempo livre durante o evento.

### ğŸ“Œ **Regras importantes**:

- A reuniÃ£o reagendada deve ocorrer **dentro do tempo total do evento**.
- As reuniÃµes **devem continuar sem sobreposiÃ§Ã£o**.
- Ã‰ permitido **mudar a ordem relativa** das reuniÃµes apÃ³s o reagendamento.

### ğŸ“˜ **Exemplos**

#### ğŸ”¹ **Exemplo 1** 
Entrada: `eventTime = 5`, `startTime = [1,3]`, `endTime = [2,5]` SaÃ­da: `2` ExplicaÃ§Ã£o: Reagende `[1,2]` para `[2,3]`, liberando o intervalo `[0,2]`.

#### ğŸ”¹ **Exemplo 2** 
Entrada: `eventTime = 10`, `startTime = [0,7,9]`, `endTime = [1,8,10]` SaÃ­da: `7` ExplicaÃ§Ã£o: Reagende `[0,1]` para `[8,9]`, liberando `[0,7]`.

#### ğŸ”¹ **Exemplo 3** 
Entrada: `eventTime = 10`, `startTime = [0,3,7,9]`, `endTime = [1,4,8,10]` SaÃ­da: `6` ExplicaÃ§Ã£o: Reagende `[3,4]` para `[8,9]`, liberando `[1,7]`.

#### ğŸ”¹ **Exemplo 4** 
Entrada: `eventTime = 5`, `startTime = [0,1,2,3,4]`, `endTime = [1,2,3,4,5]` SaÃ­da: `0` ExplicaÃ§Ã£o: NÃ£o hÃ¡ tempo livre, todas as unidades de tempo estÃ£o ocupadas.

### ğŸ“ **RestriÃ§Ãµes**

- `1 <= eventTime <= 10â¹`
- `n == startTime.length == endTime.length`
- `2 <= n <= 10âµ`
- `0 <= startTime[i] < endTime[i] <= eventTime`
- `endTime[i] <= startTime[i + 1]`, para `i` no intervalo `[0, n - 2]`

### Solution

```
public class Solution {
Â  Â  public int MaxFreeTime(int eventTime, int[] startTime, int[] endTime) {
Â  Â  Â  Â  int n = startTime.Length;
Â  Â  Â  Â  int maxFreeTime = 0;

Â  Â  Â  Â  for (int removed = 0; removed < n; removed++) {

Â  Â  Â  Â  Â  Â  // Criar nova lista de reuniÃµes sem a reuniÃ£o 'removed'
Â  Â  Â  Â  Â  Â  List<(int start, int end)> meetings = new List<(int, int)>();
Â  Â  Â  Â  Â  Â  for (int i = 0; i < n; i++) {
Â  Â  Â  Â  Â  Â  Â  Â  if (i != removed) meetings.Add((startTime[i], endTime[i]));
Â  Â  Â  Â  Â  Â  }


Â  Â  Â  Â  Â  Â  // Ordenar reuniÃµes por inÃ­cio
Â  Â  Â  Â  Â  Â  meetings.Sort((a, b) => a.start.CompareTo(b.start));

Â  Â  Â  Â  Â  Â  // Gerar gaps
Â  Â  Â  Â  Â  Â  List<(int start, int end)> gaps = new List<(int, int)>();
Â  Â  Â  Â  Â  Â  int prevEnd = 0;
Â  Â  Â  Â  Â  Â  foreach (var m in meetings) {
Â  Â  Â  Â  Â  Â  Â  Â  if (m.start > prevEnd) gaps.Add((prevEnd, m.start));
Â  Â  Â  Â  Â  Â  Â  Â  prevEnd = Math.Max(prevEnd, m.end);
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  if (prevEnd < eventTime) gaps.Add((prevEnd, eventTime));

Â  Â  Â  Â  Â  Â  // DuraÃ§Ã£o da reuniÃ£o removida
Â  Â  Â  Â  Â  Â  int duration = endTime[removed] - startTime[removed];

Â  Â  Â  Â  Â  Â  // Tentar colocar essa reuniÃ£o em cada gap
Â  Â  Â  Â  Â  Â  foreach (var g in gaps) {
Â  Â  Â  Â  Â  Â  Â  Â  if (g.end - g.start >= duration) {

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  // Simula inserir a reuniÃ£o aqui
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  List<(int start, int end)> newMeetings = new List<(int, int)>(meetings);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  newMeetings.Add((g.start, g.start + duration));
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  newMeetings.Sort((a, b) => a.start.CompareTo(b.start));

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  // Recalcula maior tempo livre
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  int prev = 0;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  int maxGap = 0;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  foreach (var m in newMeetings) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (m.start > prev)
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  maxGap = Math.Max(maxGap, m.start - prev);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  prev = Math.Max(prev, m.end);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  maxGap = Math.Max(maxGap, eventTime - prev);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  maxFreeTime = Math.Max(maxFreeTime, maxGap);
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  }

Â  Â  Â  Â  return maxFreeTime;
Â  Â  }
}
```

