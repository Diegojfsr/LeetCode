### ğŸ” 3333. Encontre a String Original Digitada II

Alice estÃ¡ tentando digitar uma string especÃ­fica no computador. No entanto, ela tende a ser desajeitada e pode pressionar uma tecla por muito tempo, fazendo com que um caractere seja digitado vÃ¡rias vezes.
VocÃª recebe uma string `word`, que representa o resultado final exibido na tela de Alice. VocÃª tambÃ©m recebe um nÃºmero inteiro positivo `k`.

ğŸ” Retorne o nÃºmero total de possÃ­veis strings originais que Alice poderia ter pretendido digitar, considerando que ela estava tentando digitar uma string de tamanho **pelo menos** `k`.
Como a resposta pode ser muito grande, retorne o resultado **mÃ³dulo 10â¹ + 7**.

### ğŸ“˜ Exemplos

#### Exemplo 1:

- Entrada: `word = "aabbccdd"`, `k = 7`
- SaÃ­da: `5`
- ExplicaÃ§Ã£o: As possÃ­veis strings originais sÃ£o:
    - `"aabbccdd"`
    - `"aabbccd"`
    - `"aabbcdd"`
    - `"aabccdd"`
    - `"abbccdd"`

#### Exemplo 2:

- Entrada: `word = "aabbccdd"`, `k = 8`
- SaÃ­da: `1`
- ExplicaÃ§Ã£o: A Ãºnica string possÃ­vel Ã© `"aabbccdd"`.

#### Exemplo 3:

- Entrada: `word = "aaabbb"`, `k = 3`
- SaÃ­da: `8`

### ğŸ“Œ RestriÃ§Ãµes

- `1 <= word.length <= 5 Ã— 10âµ`
- `word` contÃ©m apenas letras minÃºsculas do alfabeto inglÃªs.
- `1 <= k <= 2000`

### Solution

```c++
  
class Solution {
public:
Â  Â  int possibleStringCount(string word, int k) {
Â  Â  Â  Â  const int mod = 1e9 + 7;
Â  Â  Â  Â  vector<int> nums;
Â  Â  Â  Â  long long ans = 1;
Â  Â  Â  Â  int cur = 0;
Â  Â  Â  Â  int n = word.size();

Â  Â  Â  Â  for (int i = 0; i < n; ++i) {
Â  Â  Â  Â  Â  Â  cur++;
Â  Â  Â  Â  Â  Â  if (i == n - 1 || word[i] != word[i + 1]) {
Â  Â  Â  Â  Â  Â  Â  Â  if (cur > 1) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (k > 0) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  nums.push_back(cur - 1);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  ans = ans * cur % mod;
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  cur = 0;
Â  Â  Â  Â  Â  Â  Â  Â  k--;
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  }

Â  Â  Â  Â  if (k < 1) {
Â  Â  Â  Â  Â  Â  return ans;
Â  Â  Â  Â  }

Â  Â  Â  Â  int m = nums.size();
Â  Â  Â  Â  vector<vector<int>> f(m + 1, vector<int>(k, 0));
Â  Â  Â  Â  f[0][0] = 1;

Â  Â  Â  Â  for (int i = 1; i <= m; ++i) {
Â  Â  Â  Â  Â  Â  int x = nums[i - 1];
Â  Â  Â  Â  Â  Â  vector<long long> s(k + 1, 0);
Â  Â  Â  Â  Â  Â  for (int j = 0; j < k; ++j) {
Â  Â  Â  Â  Â  Â  Â  Â  s[j + 1] = (s[j] + f[i - 1][j]) % mod;
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  for (int j = 0; j < k; ++j) {
Â  Â  Â  Â  Â  Â  Â  Â  int l = max(0, j - x);
Â  Â  Â  Â  Â  Â  Â  Â  f[i][j] = (s[j + 1] - s[l] + mod) % mod;
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  }

Â  Â  Â  Â  long long sum = 0;
Â  Â  Â  Â  for (int j = 0; j < k; ++j) {
Â  Â  Â  Â  Â  Â  sum = (sum + f[m][j]) % mod;
Â  Â  Â  Â  }

Â  Â  Â  Â  return (ans - sum + mod) % mod;
Â  Â  }
};
```

###  Daily Coding Challenge Completed!

Completion Streak:3Days
Consistency is key, see youÂ tomorrow!
