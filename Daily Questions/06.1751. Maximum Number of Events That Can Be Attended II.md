

### ðŸ§¾ NÃºmero MÃ¡ximo de Eventos que Podem Ser Assistidos II

VocÃª recebe um array de eventos, onde `events[i] = [startDayáµ¢, endDayáµ¢, valueáµ¢]`. O evento `i` comeÃ§a no dia `startDayáµ¢` e termina no dia `endDayáµ¢`. Se vocÃª participar deste evento, receberÃ¡ um valor de `valueáµ¢`.
VocÃª tambÃ©m recebe um inteiro `k`, que representa o nÃºmero mÃ¡ximo de eventos que vocÃª pode participar.

### ðŸ“Œ **Regras:**

- VocÃª sÃ³ pode participar de **um evento por vez**.
- Se decidir participar de um evento, deve assisti-lo **por completo**.
- O dia final Ã© **inclusivo**: ou seja, **nÃ£o Ã© permitido** participar de dois eventos onde um comeÃ§a no mesmo dia em que o outro termina.

### ðŸŽ¯ **Objetivo:** 
Retorne a **maior soma possÃ­vel de valores** que vocÃª pode obter participando de atÃ© `k` eventos.

### ðŸ“š Exemplos

#### Exemplo 1:

```
Entrada: events = [[1,2,4],[3,4,3],[2,3,1]], k = 2
SaÃ­da: 7
ExplicaÃ§Ã£o: Escolha os eventos 0 e 1 (Ã­ndice 0), com valores 4 + 3 = 7.
```

##xemplo 2:

```
Entrada: events = [[1,2,4],[3,4,3],[2,3,10]], k = 2
SaÃ­da: 10
ExplicaÃ§Ã£o: Escolha apenas o evento 2 (valor 10). Os outros se sobrepÃµem.
```

#### Exemplo 3:

```
Entrada: events = [[1,1,1],[2,2,2],[3,3,3],[4,4,4]], k = 3
SaÃ­da: 9
ExplicaÃ§Ã£o: Os eventos nÃ£o se sobrepÃµem, mas sÃ³ Ã© possÃ­vel escolher 3. Pegue os 3 de maior valor.
```

### ðŸ”’ RestriÃ§Ãµes

- 1â‰¤kâ‰¤events.length1 \leq k \leq \text{events.length}
- 1â‰¤kÃ—events.lengthâ‰¤1061 \leq k \times \text{events.length} \leq 10^6
- 1â‰¤startDayiâ‰¤endDayiâ‰¤1091 \leq \text{startDay}i \leq \text{endDay}i \leq 10^9
- 1â‰¤valueiâ‰¤106


### Solution

```c#
public class Solution {
Â  Â  public int MaxValue(int[][] events, int k) {
Â  Â  Â  Â  Array.Sort(events, (a, b) => a[0] - b[0]); // Sort by start day
Â  Â  Â  Â  int n = events.Length;
Â  Â  Â  Â  int[] startDays = events.Select(e => e[0]).ToArray();

Â  Â  Â  Â  // Memoization: dp[i][k] = max value starting from event i with k events left
Â  Â  Â  Â  var memo = new int[n, k + 1];
Â  Â  Â  Â  for (int i = 0; i < n; i++)
Â  Â  Â  Â  Â  Â  for (int j = 0; j <= k; j++)
Â  Â  Â  Â  Â  Â  Â  Â  memo[i, j] = -1;

Â  Â  Â  Â  int Dfs(int i, int remaining) {
Â  Â  Â  Â  Â  Â  if (i == n || remaining == 0) return 0;
Â  Â  Â  Â  Â  Â  if (memo[i, remaining] != -1) return memo[i, remaining];

Â  Â  Â  Â  Â  Â  // Binary search for the next non-overlapping event
Â  Â  Â  Â  Â  Â  int next = Array.BinarySearch(startDays, events[i][1] + 1);
Â  Â  Â  Â  Â  Â  if (next < 0) next = ~next;

Â  Â  Â  Â  Â  Â  // Option 1: Skip current event
Â  Â  Â  Â  Â  Â  int skip = Dfs(i + 1, remaining);

Â  Â  Â  Â  Â  Â  // Option 2: Take current event
Â  Â  Â  Â  Â  Â  int take = events[i][2] + Dfs(next, remaining - 1);

Â  Â  Â  Â  Â  Â  return memo[i, remaining] = Math.Max(skip, take);
Â  Â  Â  Â  }
Â  Â  Â  Â  return Dfs(0, k);
Â  Â  }
}
```







