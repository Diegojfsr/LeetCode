## ğŸ§© 594. SubsequÃªncia Harmoniosa Mais Longa

Definimos um **array harmonioso** como um array em que a diferenÃ§a entre o seu valor mÃ¡ximo e o seu valor mÃ­nimo Ã© exatamente **1**.
Dado um array de inteiros `nums`, retorne o comprimento da **maior subsequÃªncia harmoniosa** entre todas as suas subsequÃªncias possÃ­veis.

### ğŸ“¥ Exemplos

#### Exemplo 1:

- **Entrada:** `nums = [1,3,2,2,5,2,3,7]`
- **SaÃ­da:** `5`
- **ExplicaÃ§Ã£o:** A maior subsequÃªncia harmoniosa Ã© `[3,2,2,2,3]`.

#### Exemplo 2:

- **Entrada:** `nums = [1,2,3,4]`
- **SaÃ­da:** `2`
- **ExplicaÃ§Ã£o:** As subsequÃªncias harmoniosas sÃ£o `[1,2]`, `[2,3]` e `[3,4]`, todas com comprimento 2.

#### Exemplo 3:

- **Entrada:** `nums = [1,1,1,1]`
- **SaÃ­da:** `0`
- **ExplicaÃ§Ã£o:** NÃ£o existe nenhuma subsequÃªncia harmoniosa.

### ğŸ“ RestriÃ§Ãµes

- 1â‰¤nums.lengthâ‰¤2Ã—1041 \leq \text{nums.length} \leq 2 \times 10^4
- âˆ’109â‰¤nums[i]â‰¤109

### Solution

```c++
  

#include <vector>
#include <unordered_map>
#include <algorithm>

class Solution {
public:
Â  Â  int findLHS(vector<int>& nums) {
Â  Â  Â  Â  std::unordered_map<int, int> frequencyMap;
Â  Â  Â  Â  for (int num : nums) {
Â  Â  Â  Â  Â  Â  ++frequencyMap[num];
Â  Â  Â  Â  }

Â  Â  Â  Â  int longestHarmoniousSequence = 0;
Â  Â  Â  Â  for (auto& [num, count] : frequencyMap) {
Â  Â  Â  Â  Â  Â  if (frequencyMap.count(num + 1)) {

Â  Â  Â  Â  Â  Â  Â  Â  longestHarmoniousSequence = std::max(longestHarmoniousSequence, count + frequencyMap[num + 1]);
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  }
Â  Â  Â  Â  return longestHarmoniousSequence;
Â  Â  }
};
```

