### ğŸ“‹ 2402. Salas de ReuniÃ£o III

ğŸ“‹ **DescriÃ§Ã£o do Problema:** 
VocÃª recebe um nÃºmero inteiro `n`, representando `n` salas numeradas de `0` a `n - 1`. TambÃ©m recebe um array 2D de inteiros `meetings`, onde `meetings[i] = [starti, endi]` significa que uma reuniÃ£o acontecerÃ¡ no intervalo semiaberto `[starti, endi)`. Todos os valores de `starti` sÃ£o Ãºnicos.

ğŸ“Œ **As reuniÃµes sÃ£o alocadas Ã s salas da seguinte forma:**

- Cada reuniÃ£o ocuparÃ¡ a sala nÃ£o utilizada com o menor nÃºmero.
- Se nÃ£o houver salas disponÃ­veis, a reuniÃ£o serÃ¡ adiada atÃ© que uma sala fique livre. A reuniÃ£o adiada deve manter a mesma duraÃ§Ã£o da original.
- Quando uma sala se torna livre, as reuniÃµes com horÃ¡rio de inÃ­cio original mais antigo tÃªm prioridade para usar essa sala.

### ğŸ§© **Objetivo:** 
Retorne o nÃºmero da sala que hospedou o maior nÃºmero de reuniÃµes. Se houver empate, retorne o nÃºmero da sala com menor nÃºmero.

ğŸ•“ **Nota:** Um intervalo semiaberto `[a, b)` inclui `a`, mas nÃ£o inclui `b`.

### Exemplos

#### ğŸ“˜ **Exemplo 1:**

```
Entrada: n = 2, meetings = [[0,10],[1,5],[2,7],[3,4]]
SaÃ­da: 0
```

**ExplicaÃ§Ã£o:**
- No tempo 0, ambas as salas estÃ£o livres. A primeira reuniÃ£o comeÃ§a na sala 0.
- No tempo 1, somente a sala 1 estÃ¡ livre. A segunda reuniÃ£o comeÃ§a nela.
- No tempo 2 e 3, todas as salas estÃ£o ocupadas. As reuniÃµes 3 e 4 sÃ£o adiadas.
- No tempo 5, a reuniÃ£o da sala 1 termina, entÃ£o a terceira reuniÃ£o comeÃ§a nela (duraÃ§Ã£o [5,10)).
- No tempo 10, todas as salas ficam livres. A quarta reuniÃ£o comeÃ§a na sala 0 (duraÃ§Ã£o [10,11)).
- Cada sala teve 2 reuniÃµes. Como hÃ¡ empate, retornamos `0`.

#### ğŸ“˜ **Exemplo 2:**

```
Entrada: n = 3, meetings = [[1,20],[2,10],[3,5],[4,9],[6,8]]
SaÃ­da: 1
```

**ExplicaÃ§Ã£o:**
- As reuniÃµes sÃ£o alocadas de forma semelhante, respeitando o uso da menor sala disponÃ­vel e adiando quando necessÃ¡rio.
- No fim, as salas 1 e 2 tÃªm 2 reuniÃµes cada, e a sala 0 apenas uma. Retornamos `1` por ser a menor entre as que tiveram mais reuniÃµes.

### ğŸ§ª RestriÃ§Ãµes:

- `1 <= n <= 100`
- `1 <= meetings.length <= 10âµ`
- `meetings[i].length == 2`
- `0 <= starti < endi <= 5 * 10âµ`
- Todos os valores de `starti` sÃ£o Ãºnicos


### Solution

```c#
using System;
using System.Collections.Generic;

public class Solution {
    public int MostBooked(int n, int[][] meetings) {
        // Ordena as reuniÃµes pelo inÃ­cio
        Array.Sort(meetings, (a, b) => a[0].CompareTo(b[0]));

        // Salas disponÃ­veis (menor nÃºmero primeiro)
        var availableRooms = new SortedSet<int>();
        for (int i = 0; i < n; i++)
            availableRooms.Add(i);

        // Salas ocupadas (quando ficam livres, e qual sala)
        var occupiedRooms = new PriorityQueue<(long endTime, int room), (long endTime, int room)>();

        // Contador de uso de cada sala
        int[] roomUsage = new int[n];

        foreach (var meeting in meetings) {
            long start = meeting[0];
            long end = meeting[1];
            long duration = end - start;

            // Libera salas que jÃ¡ terminaram antes da nova reuniÃ£o comeÃ§ar
            while (occupiedRooms.Count > 0 && occupiedRooms.Peek().endTime <= start) {
                var roomData = occupiedRooms.Dequeue();
                availableRooms.Add(roomData.room);
            }

            if (availableRooms.Count > 0) {
                // Sala disponÃ­vel de menor nÃºmero
                int room = availableRooms.Min;
                availableRooms.Remove(room);
                occupiedRooms.Enqueue((end, room), (end, room));
                roomUsage[room]++;
            } else {
                // Nenhuma sala livre â€” adia reuniÃ£o para a mais prÃ³xima disponÃ­vel
                var next = occupiedRooms.Dequeue();
                int room = next.room;
                long newEnd = next.endTime + duration;
                occupiedRooms.Enqueue((newEnd, room), (newEnd, room));
                roomUsage[room]++;
            }
        }

        // Encontra a sala com mais reuniÃµes
        int maxCount = 0, answer = 0;
        for (int i = 0; i < n; i++) {
            if (roomUsage[i] > maxCount) {
                maxCount = roomUsage[i];
                answer = i;
            }
        }

        return answer;
    }
}
```



