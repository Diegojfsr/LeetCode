## ðŸ§¾ Reagendar ReuniÃµes para o MÃ¡ximo de Tempo Livre I

VocÃª recebe um inteiro `eventTime` que representa a duraÃ§Ã£o de um evento, onde o evento ocorre do tempo `t = 0` atÃ© `t = eventTime`.
VocÃª tambÃ©m recebe dois arrays inteiros `startTime` e `endTime`, ambos de tamanho `n`. Eles representam o horÃ¡rio de inÃ­cio e fim de `n` reuniÃµes **nÃ£o sobrepostas**, onde a reuniÃ£o `i` ocorre no intervalo `[startTime[i], endTime[i]]`.
VocÃª pode **reagendar no mÃ¡ximo** `k` **reuniÃµes**, movendo seu horÃ¡rio de inÃ­cio (mantendo a mesma duraÃ§Ã£o), com o objetivo de **maximizar o maior perÃ­odo contÃ­nuo de tempo livre** durante o evento.
As reuniÃµes devem manter a **ordem relativa original** e continuar **sem sobreposiÃ§Ã£o**.
Retorne o **maior tempo livre possÃ­vel** apÃ³s o reagendamento das reuniÃµes.

> **Nota:** As reuniÃµes nÃ£o podem ser reagendadas para fora do intervalo do evento.

## ðŸ“˜ Exemplos

### Exemplo 1:
**Entrada:**
```
eventTime = 5
k = 1
startTime = [1, 3]
endTime = [2, 5]
```

**SaÃ­da:** `2`

**ExplicaÃ§Ã£o:** Reagende a reuniÃ£o `[1, 2]` para `[2, 3]`, deixando o intervalo `[0, 2]` livre.

### Exemplo 2:

**Entrada:**
```
eventTime = 10
k = 1
startTime = [0, 2, 9]
endTime = [1, 4, 10]
```

**SaÃ­da:** `6`

**ExplicaÃ§Ã£o:** Reagende a reuniÃ£o `[2, 4]` para `[1, 3]`, deixando o intervalo `[3, 9]` livre.

### Exemplo 3:

**Entrada:**
```
eventTime = 5
k = 2
startTime = [0, 1, 2, 3, 4]
endTime = [1, 2, 3, 4, 5]
```

**SaÃ­da:** `0`

**ExplicaÃ§Ã£o:** NÃ£o hÃ¡ nenhum tempo livre durante o evento.

## ðŸ“Œ RestriÃ§Ãµes

- 1â‰¤eventTimeâ‰¤1091 \leq \text{eventTime} \leq 10^9
- n=startTime.length=endTime.lengthn = \text{startTime.length} = \text{endTime.length}
- 2â‰¤nâ‰¤1052 \leq n \leq 10^5
- 1â‰¤kâ‰¤n1 \leq k \leq n
- 0â‰¤startTime[i]<endTime[i]â‰¤eventTime0 \leq \text{startTime}[i] < \text{endTime}[i] \leq \text{eventTime}
- endTime[i]â‰¤startTime[i+1]\text{endTime}[i] \leq \text{startTime}[i + 1] para todo iâˆˆ[0,nâˆ’2]


### Solution

```
public class Solution {

Â  Â  public int MaxFreeTime(int eventTime, int k, IList<int> startTime, IList<int> endTime) {
Â  Â  Â  Â  int n = startTime.Count;
Â  Â  Â  Â  List<int> gaps = new List<int>();

Â  Â  Â  Â  // Gap antes da primeira reuniÃ£o
Â  Â  Â  Â  gaps.Add(startTime[0]);

Â  Â  Â  Â  // Gaps entre reuniÃµes
Â  Â  Â  Â  for (int i = 1; i < n; i++) {
Â  Â  Â  Â  Â  Â  gaps.Add(startTime[i] - endTime[i - 1]);
Â  Â  Â  Â  }

Â  Â  Â  Â  // Gap apÃ³s a Ãºltima reuniÃ£o
Â  Â  Â  Â  gaps.Add(eventTime - endTime[n - 1]);

Â  Â  Â  Â  // Sliding window de tamanho k + 1
Â  Â  Â  Â  int maxGapSum = 0;
Â  Â  Â  Â  int windowSum = 0;

Â  Â  Â  Â  for (int i = 0; i < gaps.Count; i++) {
Â  Â  Â  Â  Â  Â  windowSum += gaps[i];
Â  Â  Â  Â  Â  Â  if (i > k) {
Â  Â  Â  Â  Â  Â  Â  Â  windowSum -= gaps[i - (k + 1)];
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  if (i >= k) {
Â  Â  Â  Â  Â  Â  Â  Â  maxGapSum = Math.Max(maxGapSum, windowSum);
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  }
Â  Â  Â  Â  return maxGapSum;
Â  Â  }
}
```

